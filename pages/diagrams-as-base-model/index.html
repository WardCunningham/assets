<html>
  <head>
    <meta charset="utf-8">
    <link rel="icon" type="image/png" sizes="16x16" href="data:image/png;base64,
iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAlmVYSWZNTQAqAAAACAAFARIAAwAAAAEAAQAAARoABQAAAAEAAABKARsABQAAAAEAAABSASgAAwAAAAEAAgAAh2kABAAAAAEAAABaAAAAAAAAAJAAAAABAAAAkAAAAAEAA5KGAAcAAAASAAAAhKACAAQAAAABAAAAEKADAAQAAAABAAAAEAAAAABBU0NJSQAAAFNjcmVlbnNob3Ql0cL1AAACe0lEQVQ4y2NgQAINDQ1MIDo+Pt4uLStncnltQ39pVd2E1Mzs3oKCAk1kNVhBbu4kdhAdk5zee/je+//7brz8f+ju+/9bztz5H+DlGguSCw0NZcOqOZSBgRnGdnOyW9c6c+n/Scs3f5u8Yuu32r5Z/81lGZpAcv///2cEUozo+mHOYssuLt+14cSN/8cffv575sXv/2ee//p/9MGnv0t3n/wfF584DUkP3BBGqKkMmfnFm088/vb/+tf/P8+/+f//3Ku/YHzx7f9/1778/73r8pP/0ZGR7dCwYGFAZigzMHiuPnQRrBlo67+zL//ADQCxz778/ffKx///Jyxa9w+oXAEeoGkzZ7KCOCnZeTNPPfvx//L7/z+RNcMNAXrn6qf/P3dfffrfw940C6QnLS2NFe6hxu5J5869/vf/wtv/f7AaABS7/OH/L2B4/A8KC58KN2DVqlXg0C+qalgPUnTp3f9fuAwAeuHnwTtv//v7+1bDDUhLg3jB1cYoe+/1F/+vfv7/48yLXxgGnAbGBjAgfy3fe/o/ULkdNE0wI0chd2331CdAZ4Kc+gPk5zNI+Nrn/99BXswtq96DlB4gwMGBARwTwgwM5m3TF/0FOffqx/9/gBjk7P9XPv3/DYreyvb+x0BlEhDbEQkPaogD2BBVBgbNjMKKW5OWbfm/eOfJv4t3nvjTs2DN//jUzH1AaT70VIsCEhoaOEB0eGR0y6bTt/9vPHnjy5az974t2XXyv5MuTyhYTUICB87M1NCwH+yK8LjEyYfuvPt/4vHX/6ef/fy/+fSt/14OlukoKRAHAAdoQECAATBDVQR4OVf6e7pW+Xt7lmdkFChgy84AhwfDU0a/DEEAAAAASUVORK5CYII=" />
  </head>
  <body>
    <style>

      body, textarea {
        font-family: "Helvetica Neue", "Arial", sans-serif;
      }

      td, th {
        border: 1px solid black;
        padding: 6px;
        width: 25%;
        font-size: smaller;
      }

      table {
        border-collapse: collapse;
        table-layout: fixed ;
        width: 100% ;
      }

      td > div {
        max-height: 100px;
        overflow-y: scroll;
        overflow-x: hidden;
      }

      li.dot::before { /* https://www.w3.org/Style/Examples/007/color-bullets.en.html*/
        content: "‚óè"; color: red;
        display: inline-block; width: 1.5em;
        margin-left: -1.5em;
      }

      li {
        cursor:pointer;
      }

      svg {
        width:100%;
        height:100%;
      }

      span.todo {
        color:red;
      }

      span.download {
        color:red;
        cursor:pointer;
      }

      span.newish {
        color:#c80;
        cursor:default;
        font-size:small;
      }

      span.erase {
        cursor:pointer;
        font-size:x-small;
      }

      :root {--waveStep: 10px; }
      @keyframes ripple {
        from {r:calc(var(--waveStep)/2);  stroke-opacity: 0%;}
        50%  {r:calc(2*var(--waveStep)); stroke-opacity: 100%;}
        to   {r:calc(4*var(--waveStep)); stroke-opacity: 0%;}
      }
      .wave {
        stroke: red;
        stroke-width: 2;
        fill: none;
        width: 80px;
        height: 80px;
      }
      .wave circle {
        r:calc(var(--waveStep)/2);
        animation: ripple
        3s linear var(--dt)
        infinite running;
      }
    </style>

    <table id="metadata">
      <tr><th>team<th>diagram<th>thing<th>description
      <tr>
        <td><div data="team">
        <td><div data="diagram">
        <td><div data="thing">
        <td><div data="description">
    </table>

    <svg id="container">
      <defs>
        <g id="wave" class="wave" >
          <circle fill=red />
          <circle style="--dt:0s;"/>
          <circle style="--dt:1s;"/>
          <circle style="--dt:2s;"/>
        </g>
      </defs>
      <image id="draw"  x="0" y="0" width="100%" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'/%3E"/>
      <use id="dot" href="#wave" x=300 y=300 visibility="hidden" />
      <line id="bolt" x1="0" y1="0" x2="100" y2="100" stroke="red" stroke-width="3" opacity=0.5 visibility="hidden" />
      <g id="glow" style="fill: red;"> </g>
      <rect id="irect" x=100 y=100 width=200 height=200 fill=none stroke=green stroke-dasharray="10" visibility="hidden" />
      <rect id="srect" x=110 y=110 width=200 height=200 fill=none stroke=red stroke-dasharray="5" visibility="hidden" />
    </svg>

    <img id=test src="#" height=5px>

    <style>

      dialog {
        width:350px;
        opacity:0.9;
      }

      label {
        color: gray;
      }

      input, textarea {
        width:100%;
        padding: 6px;
      }

      input.radio {
        width:10%;
      }

      div.buttons {
        float:right;
      }

      #sfield {
        list-style-type: none;
        font-size: smaller;
        padding-left: 0px;
        max-height:400px;
        overflow:scroll;
      }

      #sfield li:hover {
        background-color:#eee;
      }

    </style>

    <!--
      https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dialog
      https://developer.mozilla.org/en-US/docs/Web/HTML/Element/output
    -->

    <datalist id="typelist">
      <option value="limit">
      <option value="process">
      <option value="service">
      <option value="system">
      <option value="tool">
      <option value="topic">
      <option value="usage">
    </datalist>

    <dialog id="describe">
      <form method="dialog">
        <p><label>scale<br>
          <input class="radio" type="radio" name="scale" value="1" checked>1x</input>
          <input class="radio" type="radio" name="scale" value="2">2x</input>
          <input class="radio" type="radio" name="scale" value="3">3x</input>
          <input class="radio" type="radio" name="scale" value="4">4x</input>
        </label></p>
        <p><label>thing<br>
          <input type="text" id="tfield" name="thing" autocomplete=off >
        </label></p>
        <p><label>type<br>
          <input type="text" id="xfield" name="type" list="typelist" autocomplete=off placeholder="optional type of thing">
        </label></p>
        <p><label>description<br>
          <textarea id="dfield" name="description" rows=8></textarea>
        </label></p>
        <div class="buttons">
          <button value="delete">delete</button>
          <button value="cancel">cancel</button>
          <button value="save">save</button>
        </div>
      </form>
    </dialog>

    <dialog id="finder">
      <form method="dialog">
        <p><label id=flab>find diagrams<br>
          <input type="text" id="ffield" name="find" autocomplete=off >
        </label></p>
        <p><label>search results<br>
          <ul id="sfield"></ul>
        </label></p>
      </form>
    </dialog>

    <script>


// http://simnet.ward.asia.wiki.org/metadata-editor.html


// S T A T E

      const uniq = (value, index, self) => self.indexOf(value) === index
      const sleep = async ms => await new Promise(resolve => setTimeout(resolve, ms))
      const version = "12" // rebuild index.json because versions must agree

      let index = {}      // index.json
      let metadetails     // team/diagram.json
      let updates = {}    // "[team,diagram]" => revised team/diagram.json

      let selection = {team:null, diagram:null, thing:null}

      let [prefix, suffix] = location.href.split(location.pathname)
      let db = prefix + location.pathname.replace('/index.html','')
      if (db.startsWith('file')) {
        db = 'https://source.datanerd.us/pages/architecture/otm'
        db = 'http://simnet.ward.asia.wiki.org/assets/pages/diagrams-as-base-model'
      }
      index = fetch(`${db}/index.json`).then(res => res.json()).then(restore)

      draw.setAttribute('href',`${db}/index.png`)


// D E B U G G I N G

      // setInterval(() => console.log(Object.keys(updates).join(', ')), 1000)

      // let mouselog = ['.', '.', '.', '.', '.', '.', '.', '.']
      // let mousehit = x => {mouselog.shift(); mouselog.push(x); console.log(mouselog.join(' '))}
      // setInterval(() => mousehit('.'), 500)
      let mousehit = x => {}

      function boxes (sbox, ibox) {
        let svg_bb = container.getBoundingClientRect()
        let bb = draw.getBoundingClientRect()

        srect.setAttribute('x',sbox.x)
        srect.setAttribute('y',sbox.y)
        srect.setAttribute('width',sbox.width)
        srect.setAttribute('height',sbox.height)
        let se = image2screen([ibox.width, ibox.height])
        irect.setAttribute('x',sbox.x)
        irect.setAttribute('y',sbox.y)
        irect.setAttribute('width',se[0])
        irect.setAttribute('height',se[1])

        srect.setAttribute('visibility','visible')
        irect.setAttribute('visibility','visible')
      }


// T R A N S F O R M


      function screen2image (xy) {
        let svg_bb = container.getBoundingClientRect()
        let bb = draw.getBoundingClientRect()
        let sbox = {x:bb.x - svg_bb.x, y:bb.y - svg_bb.y, height:bb.height, width:bb.width}
        let ibox = {width:test.naturalWidth, height:test.naturalHeight}

        let x = Math.round((xy[0]-bb.x+svg_bb.x) * ibox.width / sbox.width)
        let y = Math.round((xy[1]-bb.y+svg_bb.y) * ibox.height / sbox.height)
        return [x,y]
      }

      function image2screen (xy) {
        let svg_bb = container.getBoundingClientRect()
        let bb = draw.getBoundingClientRect()
        let sbox = {x:bb.x - svg_bb.x, y:bb.y - svg_bb.y, height:bb.height, width:bb.width}
        let ibox = {width:test.naturalWidth, height:test.naturalHeight}

        let x = xy[0] * sbox.width / ibox.width + bb.x-svg_bb.x
        let y = xy[1] * sbox.height / ibox.height + bb.y-svg_bb.y
        return [x,y]
      }

      window.addEventListener('resize', (e) => {
        setscale()
        dot.setAttribute('visibility','hidden')
        glow.innerHTML = ''
        if (selection.team && selection.diagram && selection.thing) {
          let thing = metadetails.things[selection.thing]
          if (thing.dot) {
            let screen = image2screen(thing.dot)
            dot.setAttribute('x',screen[0])
            dot.setAttribute('y',screen[1])
            dot.setAttribute('visibility','visibile')
          }
        }
      })

      let mouse = {down: false, moved: false, x:0, y:0}
      draw.addEventListener("mousedown", e => {mouse.down = true; mouse.moved = false; mouse.x=e.screenX; mouse.y=e.screenY; mousehit('down')})
      draw.addEventListener("mouseup", e => {mouse.down = false; mousehit('up')})
      draw.addEventListener("mousemove", e => {
        if(mouse.down) {
          let dx = e.screenX - mouse.x
          let dy = e.screenY - mouse.y
          // console.log('drag',[dx, dy])
          mouse.x += dx
          mouse.y += dy
          scroll(dx,dy)
          mouse.moved = dx != 0 || dy != 0
        }
      })

      function scroll (dx, dy) {
        draw.setAttribute('x',draw.getAttribute('x')*1 + dx)
        draw.setAttribute('y',draw.getAttribute('y')*1 + dy)
        dot.setAttribute('x', dot.getAttribute('x')*1 + dx)
        dot.setAttribute('y', dot.getAttribute('y')*1 + dy)
      }


// S E L E C T I O N

      function restore (json) {
        index = json
        console.error('version',{json:index.version,html:version})
        if (index.version && version != index.version) {
          let ok = confirm(`Ready to reload for app version ${index.version}?`)
          if (ok) location.reload(true)
        }
        li(Object.keys(index.data),'team')
        gotohash()
      }

      async function getmetadata(team, diagram) {
        let key = JSON.stringify([team,diagram])
        if (updates[key]) return updates[key]
        let local = window.localStorage.getItem(key) && JSON.parse(window.localStorage.getItem(key))
        let remote = await fetch(`${db}/data/${team}/${diagram}.json`).then(res => {return res.ok? res.json() : null})
        if (local) {
          if (remote && remote.date && remote.date >= (local.date || 0)) {
            window.localStorage.removeItem(key)
            return remote
          } else {
            return local
          }
        }
        let meta = index.data[selection.team][selection.diagram]
        return remote || mkmetadata(meta.things || [])
      }

      function putmetadata(team, diagram) {
        metadetails.date = Date.now()
        let key = JSON.stringify([team,diagram])
        let val = JSON.stringify(metadetails)
        updates[key] = JSON.parse(val)
        window.localStorage.setItem(key,val)
      }

      function mkmetadata(things) {
        let meta = {things:{}}
        for (let thing of things) {
          meta.things[thing] = {type:'any'}
        }
        // console.log('mkmetadata',meta)
        return meta
      }

      async function showimage (team, diagram) {
        let meta = index.data[team][diagram]
        let ext = meta.extension || 'svg'
        await getimage(`${db}/data/${team}/${diagram}.${ext}`)
        setscale()
        dot.setAttribute('visibility','hidden')
      }

      function getimage(src) {
        return new Promise((resolve, reject) => {
          test.addEventListener("load", () => resolve());
          test.addEventListener("error", err => reject(err));
          draw.setAttribute('href', src)
          test.setAttribute('src', src)
        });
      };

      function urlhash() {
        let hash = ''
        if (selection.team) {
          hash += `#${selection.team}`
          if (selection.diagram) {
            hash += `/${selection.diagram}`
            if (selection.thing) {
              hash += `/${selection.thing}`
            }
          }
        }
        return hash
      }

      async function gotohash() {
        let want = {team:null, diagram:null, thing:null}
        if (location.hash.match(/^#/)) {
          let fields = location.hash.substr(1).split('/')
          if (fields[0]) {
            want.team = decodeURIComponent(fields.shift())
            if (fields[0]) {
              want.diagram = decodeURIComponent(fields.shift())
              if (fields[0]) {
                want.thing = decodeURIComponent(fields.shift())
              }
            }
          }
        }
        if (selection.team != want.team ||
            selection.diagram != want.diagram ||
            selection.thing != want.thing) {
          selection = want
          await refresh()
        }
      }

      window.onhashchange = gotohash


// D O W N L O A D

      function modified(team, list) {
        return list.map(diagram => {
          let key = JSON.stringify([team,diagram])
          if (updates[key]) {
            return `${diagram} <span class=download onclick="download('${diagram}')">‚á©</span>`
          } else if (window.localStorage.getItem(key)) {
            return `${diagram} <span class=erase onclick="erase('${diagram}')">üÖá</span>`
          } else {
            let date = index.data[team][diagram].date || 0
            if (date && date > Date.now()-604800000) {
              return `${diagram} <span class=newish>‚òº</span>`
            }
          }
          return diagram
        })
      }

      function newish(list) {
        return list.map(team => {
          let diagrams = index.data[team]
          let date = Object.keys(diagrams).reduce((s,e) => Math.max(s,diagrams[e].date||0), 0)
          if (date > Date.now()-604800000) {
            return `${team} <span class=newish>‚òº</span>`
          }
          return team
        })
      }

      function download(diagram){
        let key = JSON.stringify([selection.team, diagram])
        let string = JSON.stringify(updates[key],null,2)
        let file = `${diagram}.json`
        emit(string,file)
        delete updates[key]
        refresh()
        // event.stopPropagation()

        function emit(string, file) {
          var data = "data:text/json;charset=utf-8," + encodeURIComponent(string);
          var anchor = document.createElement('a');
          anchor.setAttribute("href",     data);
          anchor.setAttribute("download", file);
          document.body.appendChild(anchor); // required for firefox
          anchor.click();
          anchor.remove();
        }
      }

      function erase(diagram) {
        let key = JSON.stringify([selection.team, diagram])
        window.localStorage.removeItem(key)
        refresh()
      }


// R E F R E S H

      const td = panel => document.querySelector(`div[data=${panel}]`)
      const li = (list,panel) => {
        td(panel).innerHTML = (list||[]).map(t => `<li class="${clean(t) == selection[panel] ? 'dot' : ''}">${t}`).join('')
        let wanted = [...td(panel).getElementsByClassName('dot')]
        if (wanted.length) {
          let w = wanted[0].getBoundingClientRect()
          let p = td(panel).getBoundingClientRect()
          if (w.top < p.top || w.bottom > p.bottom) wanted[0].scrollIntoView(false)
        }
      }

      async function current() {
        let choices = {teams:[], diagrams:[], things:[], details:{}}
        dot.setAttribute('visibility','hidden')
        choices.teams = Object.keys(index.data)
        if (selection.team) {
          choices.diagrams = Object.keys(index.data[selection.team])
          if (selection.diagram) {
            metadetails = await getmetadata(selection.team, selection.diagram)
            choices.things = Object.keys(metadetails.things).filter(t => metadetails.things[t])
            if (selection.thing) {
              choices.details = metadetails.things[selection.thing] || {}
            }
            setscale()
          }
        }
        return choices
      }

      async function refresh() {
        glow.innerHTML = ''
        let choices = await current()
        console.log(selection, choices)
        li(newish(choices.teams), 'team')
        li(modified(selection.team,choices.diagrams), 'diagram')
        if (selection.diagram) await showimage(selection.team, selection.diagram)
        else draw.setAttribute('href',`${db}/index.png`)
        li(choices.things, 'thing')
        td('description').innerHTML = markup(choices.details.description) || todo(choices.details)
        if (choices.details.dot) showdot(choices.details.dot)
      }

    function todo(thing) {
      if (!selection.diagram) return ''
      let target = thing.dot ? 'dot' : 'diagram'
      let todo = `<span class=todo>Click ${target} to edit.</span>`
      if (Object.keys(metadetails.things).length) {
        todo += `<br><span class=todo>Click ‚óè here to see all things.</span>`
      }
      return todo
    }

      function markup(text) {
        if (!text) return text
        return text
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/(https:\/\/source\.datanerd\.us.*?)(\s|$)/g, '<a href="$1" target="_blank">GHE</a>$2')
          .replace(/(https:\/\/el-dorado\.datanerd\.us.*?)(\s|$)/g, '<a href="$1" target="_blank">El Dorado</a>$2')
          .replace(/(https:\/\/(staging-)?one\.newrelic\.com.*?)(\s|$)/g, '<a href="$1" target="_blank">NR1</a>$3')
          .replace(/(https:\/\/nerdlife\.datanerd\.us*?)(\s|$)/g, '<a href="$1" target="_blank">NerdLife</a>$2')
          .replace(/(https:\/\/pages\.datanerd\.us.*?)(\s|$)/g, '<a href="$1" target="_blank">pages</a>$2')
          .replace(/(https:\/\/staging-api\.newrelic\.com\/graphiql\?.*?)(\s|$)/g, '<a href="$1" target="_blank">graphiql</a>$2')
          .replace(/(https?:\/\/.*?)(\s|$)/g, '<a href="$1" target="_blank">web</a>$2')
          .replace(/\n/g, '<br>')
      }


// N A V I G A T E

      const clean = text => text.replace('‚á©','').replace('üÖá','').replace('‚òº','').replace(/<span.*/,'').trim()

      metadata.onclick = async (e) => {
        if(e.target.className == 'todo') return glowdots()
        if(e.target.tagName == 'SPAN') return // download button
        if(e.target.tagName == 'TH') return search(e.target.innerText)
        let panel = e.target.parentElement.getAttribute('data')
        if (!panel) return
        let item = clean(e.target.innerText)
        selection[panel] = item
        switch (panel) {
          case 'team':
            selection.diagram = null
            selection.thing = null
            break
          case 'diagram':
            selection.thing = null
            break
          case 'thing':
            break
          default:
            console.error('cant dispatch', e.path[1])
        }
        refresh()
        window.location = urlhash()
      }

      // window.addEventListener('keydown', (e) => {
      //   if (e.key == 'Shift' && selection.diagram) glowdots()
      // })

      async function glowdots() {
        selection.thing = null
        await refresh()
        td('description').innerHTML = `<span class=todo>Click dot to select.</span>`
        for (let thing in metadetails.things) {
          if (metadetails.things[thing]) {
            let dot = metadetails.things[thing].dot
            if (dot) {
              let xy = image2screen(dot)
              let el = document.createElementNS("http://www.w3.org/2000/svg", "use");
              el.setAttribute('href', '#wave');
              el.setAttribute('x', xy[0]);
              el.setAttribute('y', xy[1]);
              el.onclick = (e) => {selection.thing = thing; refresh(); window.location = urlhash()}
              glow.append(el)
            }
          }
        }
      }


// S E A R C H

      let just = []       // panels with search results

      function search(panel) {
        ffield.data = panel
        ffield.placeholder = `${panel} ${panel == 'description' ? 'words' : 'name'}`
        ffield.value = ''
        sfield.innerHTML = ''
        finder.showModal()
      }

      function found(hit) {
        if (hit.thing) return `${hit.thing} (${hit.diagram})`
        if (hit.diagram) return `${hit.diagram} (${hit.team})`
        if (hit.team) return `${hit.team}`
        return 'n/a'
      }

      ffield.addEventListener('keyup', async e => {
        let panel = ffield.data
        let want = e.target.value.toLowerCase()
        if (index.paths && index.paths[want]) {
          just = index.paths[want]
        } else {
          just = []
          for (let team of Object.keys(index.data)) {
            if (panel == 'team') {
              if (team.toLowerCase().includes(want)) {
                just.push({team})
              }
            } else {
              for (let diagram of Object.keys(index.data[team])) {
                if (panel == 'diagram') {
                  if (diagram.toLowerCase().includes(want)) {
                    just.push({team,diagram})
                  }
                } else {
                  for (let thing of index.data[team][diagram].things) {
                    if (thing.toLowerCase().includes(want)) {
                      just.push({team,diagram,thing})
                    }
                  }
                }
              }
            }
          }
        }
        sfield.innerHTML = just.map((hit,i) => `<li data=${i}>${found(hit)}</li>`).join("\n")
        if (just.length) selection = just[0]
        refresh()
      })

      sfield.addEventListener('click', async e => {
        selection = just[e.target.getAttribute('data')*1]
        refresh()
        finder.close()
      })

      sfield.addEventListener('mouseover', async e => {
        selection = just[e.target.getAttribute('data')*1]
        refresh()
      })

      finder.addEventListener('close', e => window.location.hash = urlhash())


// E D I T

      function showdot(xy) {
        let x1 = dot.getAttribute('x')
        let y1 = dot.getAttribute('y')
        let screen = expose(image2screen(xy))
        dot.setAttribute('x',screen[0])
        dot.setAttribute('y',screen[1])
        dot.setAttribute('visibility','visible')
        let x2 = dot.getAttribute('x')
        let y2 = dot.getAttribute('y')
        flash(x1,y1,x2,y2)
      }


      function setscale() {
        let svg_bb = container.getBoundingClientRect()
        let aspect = svg_bb.width / (svg_bb.height-svg_bb.top)
        let width =  100
        if ((test.naturalWidth / test.naturalHeight) < aspect) {
          width *= (test.naturalWidth / test.naturalHeight) / aspect
        }
        if (selection.thing) {
          let details = metadetails.things[selection.thing] || {}
          width *= details.scale || 1
        }
        draw.setAttribute('x','0')
        draw.setAttribute('y','0')
        draw.setAttribute('width',`${width}%`)
        dot.setAttribute('visibility','visable')
      }

      function expose(xy) {
        if (((metadetails.things[selection.thing] || {}).scale || 1) == 1) return xy
        const boundary = (t) => {let m = Math.round(t*0.1); return [m,t-m]}
        let svg_bb = container.getBoundingClientRect()
        let [l,r] = boundary(svg_bb.width)
        let [t,b] = boundary(svg_bb.height-svg_bb.top)
        let dx = dy = 0
        if (xy[0]<l) dx = l-xy[0]
        if (xy[0]>r) dx = r-xy[0]
        if (xy[1]<t) dy = t-xy[1]
        if (xy[1]>b) dy = b-xy[1]
        scroll(dx, dy)
        return [xy[0]+dx, xy[1]+dy]
      }

      async function flash(x1, y1, x2, y2) {
        bolt.setAttribute('x1',x1)
        bolt.setAttribute('y1',y1)
        bolt.setAttribute('x2',x2)
        bolt.setAttribute('y2',y2)
        bolt.setAttribute('visibility','visible')
        await sleep(600)
        bolt.setAttribute('visibility','hidden')
      }

      draw.onclick = (e) => {
        mousehit('click-' + (mouse.moved ? 'move' : 'still'))
        if (mouse.moved) return
        let x = e.offsetX
        let y = e.offsetY
        dot.setAttribute('x',x)
        dot.setAttribute('y',y)
        dot.setAttribute('visibility','visible')
        if (selection.thing) {
          let thing = metadetails.things[selection.thing]
          thing.dot = screen2image([x,y])
          putmetadata(selection.team, selection.diagram)
          refresh()
        }
      }

      dot.onclick = (e) => {
        let thing = metadetails.things[selection.thing]
        tfield.value = selection.thing || ''
        xfield.value = (thing && thing.type && thing.type!='any') ? thing.type : ''
        dfield.value = thing ? thing.description || '' : ''
        // console.log('dot click', {thing})
        let scale = (thing && thing.scale) ? thing.scale : "1"
        describe.querySelector(`input[name="scale"][value="${scale}"]`).setAttribute('checked',true)
        dfield.placeholder = 'describe this thing'
        if (!selection.thing) {
          tfield.placeholder = 'name new thing'
          dfield.placeholder = 'describe new thing'
        }
        describe.showModal()
      }

      describe.addEventListener('close',e => {
        let button = e.target.returnValue
        if (button == 'save') saveit()
        if (button == 'delete') deleteit()
        refresh()
      })

      function saveit() {
        let thing = {}
        if (!tfield.value) return
        if (!selection.thing) {
          selection.thing = tfield.value
          if (metadetails.things[selection.thing]) {
            thing = metadetails.things[selection.thing]
          } else {
            metadetails.things[selection.thing] = thing
            index.data[selection.team][selection.diagram].things.push(selection.thing)
          }
          // console.log('newthing',{selection,thing,metadetails})
        } else {
          thing = metadetails.things[selection.thing]
          // console.log('oldthing',{selection, thing, metadetails})
        }
        if (selection.thing != tfield.value) {
          deleteit()
          selection.thing = tfield.value
          metadetails.things[selection.thing] = thing
          index.data[selection.team][selection.diagram].things.push(selection.thing)
        }
        let xy = [dot.getAttribute('x'), dot.getAttribute('y')]
        thing.dot = screen2image(xy)
        thing.description = dfield.value
        thing.type = xfield.value || 'any'
        thing.scale = describe.querySelector('input[name="scale"]:checked').value
        putmetadata(selection.team, selection.diagram)
        selection.thing = null
      }

      function deleteit() {
        let thing = metadetails.things[selection.thing]
        if (thing) {
           let names = index.data[selection.team][selection.diagram].things
           names.splice(names.indexOf(selection.thing), 1)
           metadetails.things[selection.thing] = null
           selection.thing = null
           putmetadata(selection.team, selection.diagram)
        }
      }

    </script>
  </body>
</html>
