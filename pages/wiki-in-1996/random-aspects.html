<table><tr>
  <td id=result>working
  <td id=stats>
  <td><button hidden>again</button>
</table>

<script type=module>
  import {Graph} from 'https://wardcunningham.github.io/graph/graph.js'
  const uniq = (value, index, self) => self.indexOf(value) === index
  const any = array => array[Math.floor(array.length * Math.random())]
  const words = name => name.replaceAll(/([a-z])([A-Z])/g, (a,b,c) => `${b}\n${c}`)
  const params = Object.fromEntries(new URLSearchParams(location.search).entries())

// fetch the nodes and edges from the lines provided

  const site = "http://ward.dojo.fed.wiki"
  const asset = "wiki-in-1996/c2Wiki1996.graphml"
  const graphml = await fetch(`${site}/assets/pages/${asset}`).then(res => res.text())
  const lines = graphml.split("\n")
  const pages = lines.filter(line => line.match('<node'))
  const links = lines.filter(line => line.match('<edge'))
  window.result.innerText = ` -- ${params.method||''} --
    ${lines.length} lines
    ${pages.length} pages
    ${links.length} links`
  lines.length = 0

// number each node and index in and out nodes as numbers

  const index = new Map()  // name => {i, in:[s,...], out:[j,...]}
  const names = []         // i => name
  pages.forEach((page,i) => {
    const name = page.match(/"(.*?)"/)[1]
    index.set(name,{i, in:[], out:[]})
    names.push(name)
  })
  pages.length = 0
  links.forEach(link => {
    const [,source,target] = link.match(/source="(.*?)" target="(.*?)"/)
    if(source != target) {
      const s = index.get(source)
      const t = index.get(target)
      s.out.push(t.i)
      t.in.push(s.i)
    }
  })
  links.length = 0
  again()
  const button = document.querySelector('button')
  button.addEventListener('click',again)
  button.hidden = false

  function again() {

// add aspects made from randomly selected starting points

  const aspects = []
  const done = []

  const nodes = name => {
    const graph = new Graph()
    graph.addNode('',{name:words(name)})
    aspects.push({name,graph})
  }

  const tree = name => {
    const here = index.get(name)
    const out = here.out.filter(i => index.get(names[i]).in.length < 5)
    if (out.length < 2) return
    if (done.includes(here.i)) return
    done.push(here.i)
    const graph = new Graph()
    graph.addNode('',{name:words(name)})
    aspects.push({name,graph})
    const todo = out.slice(0,5)
    for(const doing of todo) {
      const nid = graph.addUniqNode('',{name:words(names[doing])})
      graph.addRel('',0,nid)
    }
  }

  const blanket = name => {
    const here = index.get(name)
    const jrs = here.out.slice(0,5)
    const srs = here.in.slice(0,3)
    console.log(name,jrs[0],names[jrs[0]])
    const srjrs = jrs
      .map(jr => [jr, index.get(names[jr]).in.slice(0,3)])
    const graph = new Graph()
    const page = i => graph.addUniqNode('',{name:words(names[i])})
    graph.addNode('',{name:words(name)})
    srs.forEach(sr => graph.addRel('',page(sr),0))
    jrs.forEach(jr => graph.addRel('',0,page(jr)))
    srjrs.forEach(([jr,srs]) =>
      srs.forEach(sr => graph.addRel('',page(sr),page(jr))))
    aspects.push({name,graph})
  }

  while (aspects.length < 30) {
    const name = any(names)
    switch (params.method) {
    case 'nodes': nodes(name); break
    case 'tree': tree(name); break
    case 'blanket': blanket(name); break
    default: tree(name)
    }
  }

// count unique nodes to charaterize this selection

  console.log({aspects})
  const all = aspects
    .map(aspect => aspect.graph.nodes)
    .flat()
  const most = all
    .map(node => node.props.name)
    .filter(uniq)

// share these aspects with other pages in the lineub

  const sourceData = aspects
  console.log(sourceData)
  window.parent.postMessage({
    action: "publishSourceData",
    name:'aspect',
    sourceData},'*')
  window.stats.innerText = `
    ${aspects.length} aspects
    ${most.length} nodes
    ${all.length - most.length} dups`

  }

</script>