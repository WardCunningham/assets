<html>
<body>

<style>
  body {font-family:
    "Helvetica Neue",
    Verdana,
    helvetica,
    Arial,
    Sans;
  }
</style>

<button onclick="doopen(event)">download</button>
<h3>Contents</h3>
<pre id=contents onclick="doclick(event)"></pre>
<h3>Reference</h3>
<pre id=reference onclick="doclick(event)"></pre>

<script>

let context, present
const asSlug = (title) => title.replace(/\s/g, '-').replace(/[^A-Za-z0-9-]/g, '').toLowerCase()
const isjson = res => res.ok ? res.json() : {}
const getpage = title => fetch(`//${context.site}/${asSlug(title)}.json`).then(isjson)
const ispresent = title => present.includes(asSlug(title))
const absent = title => ispresent(title) ? '' : ' <font color=red>✘</font>'
const line = title => `<span>${title}</span>${absent(title)}\n`

window.addEventListener("message", handler)
let message = { action:"sendFrameContext" }
window.parent.postMessage(message, "*")

let titles = []
let refs = []

let troubles = {}
const trouble = (prob, title) => {
  let list = troubles[prob] = troubles[prob] || []
  if(!list.includes(title)) list.push(title)
}

let html = [`
  <meta charset="utf-8"/>
  <style>
    body {
      font-family:helvetica;
      width:550px;
    }
  </style>
`]

async function handler ({data}) {
  if (data.action == "frameContext") {
    window.removeEventListener("message", handler)
    context = data
    let sitemap = await fetch(`//${context.site}/system/sitemap.json`).then(res => res.json())
    present = sitemap.map(info => info.slug)
    visit(context.page)
    contents.innerHTML = titles.map(line).join("")
  }
}

function visit(page) {
  const link = /\[\[(.*?)\]\]/g
  for (let item of page.story) {
    let text = item.text
    while (match = link.exec(text)) {
      titles.push(match[1])
    }
  }
}

function doclick(event) {
  let title = event.target.innerText
  console.log(title)
}

async function doopen(event) {
  reference.scrollIntoView(false)
  let pages = await Promise.all(titles.filter(ispresent).map(title => getpage(title)))
  emit(pages)

  while(refs.length) {
    reference.innerHTML += refs.map(line).join("")+"\n"
    reference.scrollIntoView(false)
    pages = await Promise.all(refs.filter(ispresent).map(title => getpage(title)))
    titles.push(...refs)
    refs = []
    emit(pages)
  }

  download(html.join("\n"),'draft-pages.html')

  let story = Object.keys(troubles).map(key => ({
    type:'paragraph',
    text:`${key} ⇒ ${troubles[key].map(title => `[[${title}]]`).join(', ')}`
  }))
  if(!story.length) story = [{type:'paragraph', text:'No problems encountered.'}]
  let message = {
    action: "showResult",
    page: {title:'Trouble', story},
    keepLineup: event.shiftKey
  }
  window.parent.postMessage(message, "*");
}

function emit(pages) {
  for (let page of pages) {
    if (!page || !page.title) continue
    html.push(`<h3 id="${asSlug(page.title)}">${page.title}</h3>`)
    for (let item of page.story) {
      switch (item.type) {
        case 'paragraph':
          html.push(`<p>${resolve(item.text)}</p>`)
          break
        case 'image':
          html.push(`<p><img width=100% src="${item.url}"><center>${resolve(item.text || item.caption)}</center></p>`)
          break
        case 'html':
          let div = document.createElement('div')
          div.innerHTML = item.text
          html.push(`<div>${resolve(div.innerHTML)}</div>`)
          break
        default:
          trouble(`Can't yet print ${item.type}`, page.title)
      }
    }    
  }
}

function resolve(text) {
  const link = /\[\[(.*?)\]\]/g
  return text.replace(link, (match, title) => {
    console.log('resolve', title)
    if (!titles.includes(title) && !refs.includes(title)) {
      refs.push(title)
    }
    return ispresent(title)
      ? `<a href=#${asSlug(title)}>${title}</a>`
      : `<font color=gray>${title}</font>`
  }).replace(/\[(https?:.*?) (.*?)\]/g,'<a href="$1">$2</a> '+linkmark())
}

function download(string, file) {
  var data = "data:text/json;charset=utf-8," + encodeURIComponent(string);
  var anchor = document.createElement('a');
  anchor.setAttribute("href",     data);
  anchor.setAttribute("download", file);
  document.body.appendChild(anchor); // required for firefox
  anchor.click();
  anchor.remove();
}

function linkmark() {
  return `<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAC0WlDQ1BJQ0MgUHJvZmlsZQAAKJGNlM9LFGEYx7+zjRgoQWBme4ihQ0ioTBZlROWuv9i0bVl/lBLE7Oy7u5Ozs9PM7JoiEV46ZtE9Kg8e+gM8eOiUl8LALALpblFEgpeS7Xlnxt0R7ccLM/N5nx/f53nf4X2BGlkxTT0kAXnDsZJ9Uen66JhU+xEhHEEdwqhTVNuMJBIDoMFjsWtsvofAvyute/v/OurStpoHhP1A6Eea2Sqw7xfZC1lqBBC5XsOEYzrE9zhbnv0x55TH8659KNlFvEh8QDUtHv+auEPNKWmgRiRuyQZiUgHO60XV7+cgPfXMGB6k73Hq6S6ze3wWZtJKdz9xG/HnNOvu4ZrE8xmtN0bcTM9axuod9lg4oTmxIY9DI4YeH/C5yUjFr/qaoulEk9v6dmmwZ9t+S7mcIA4TJ8cL/TymkXI7p3JD1zwW9KlcV9znd1Yxyeseo5g5U3f/F/UWeoVR6GDQYNDbgIQk+hBFK0xYKCBDHo0iNLIyN8YitjG+Z6SORIAl8q9TzrqbcxtFyuZZI4jGMdNSUZDkD/JXeVV+Ks/JX2bDxeaqZ8a6qanLD76TLq+8ret7/Z48fZXqRsirI0vWfGVNdqDTQHcZYzZcVeI12P34ZmCVLFCpFSlXadytVHJ9Nr0jgWp/2j2KXZpebKrWWhUXbqzUL03v2KvCrlWxyqp2zqtxwXwmHhVPijGxQzwHSbwkdooXxW6anRcHKhnDpKJhwlWyoVCWgUnymjv+mRcL76y5o6GPGczSVImf/4RVyGg6CxzRf7j/c/B7xaOxIvDCBg6frto2ku4dIjQuV23OFeDCN7oP3lZtzXQeDj0BFs6oRavkSwvCG4pmdxw+6SqYk5aWzTlSuyyflSJ0JTEpZqhtLZKi65LrsiWL2cwqsXQb7Mypdk+lnnal5lO5vEHnr/YRsPWwXP75rFzeek49rAEv9d/AvP1FThgxSQAAAAlwSFlzAAALEwAACxMBAJqcGAAAAKtJREFUGJVtkLERwjAMRZ+5UHmmNNpCrpMloMi5gCXcO1MkLWwBS6SCO1EQgkP4d2q+nr50cmZGqbZt18YsV4IxRqv2FcfD8XeYXWl0Xefutzsxxk1iFUJYrfLeU9f1BtwB5JzJOeO9R1UREcZxXCVX5R0l1Pc9AKfz6ZsIoKpcrpcFmqaJlJJ7Pp6klByqah8Nw2BN05iZ2ezzqWU1gIggIv/e+AZDCH+bpV442lpGxygDswAAAABJRU5ErkJggg==" alt="" />`
}

</script>

</body>
</html>